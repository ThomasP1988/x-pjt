// @generated by protobuf-ts 2.2.2
// @generated from protobuf file "orderbook.proto" (package "orderbooks", syntax proto3)
// tslint:disable
import { ServiceType } from "@protobuf-ts/runtime-rpc";
import type { BinaryWriteOptions } from "@protobuf-ts/runtime";
import type { IBinaryWriter } from "@protobuf-ts/runtime";
import { WireType } from "@protobuf-ts/runtime";
import type { BinaryReadOptions } from "@protobuf-ts/runtime";
import type { IBinaryReader } from "@protobuf-ts/runtime";
import { UnknownFieldHandler } from "@protobuf-ts/runtime";
import type { PartialMessage } from "@protobuf-ts/runtime";
import { reflectionMergePartial } from "@protobuf-ts/runtime";
import { MESSAGE_TYPE } from "@protobuf-ts/runtime";
import { MessageType } from "@protobuf-ts/runtime";
/**
 * @generated from protobuf message orderbooks.OrderListResult
 */
export interface OrderListResult {
    /**
     * @generated from protobuf field: string next = 1;
     */
    next: string;
    /**
     * @generated from protobuf field: repeated orderbooks.Order orders = 2;
     */
    orders: Order[];
}
/**
 * @generated from protobuf message orderbooks.Order
 */
export interface Order {
    /**
     * @generated from protobuf field: string id = 1;
     */
    id: string;
    /**
     * @generated from protobuf field: string status = 2;
     */
    status: string;
    /**
     * @generated from protobuf field: string userId = 3;
     */
    userId: string;
    /**
     * @generated from protobuf field: string symbol = 4;
     */
    symbol: string;
    /**
     * @generated from protobuf field: orderbooks.SideOrder side = 5;
     */
    side: SideOrder;
    /**
     * @generated from protobuf field: orderbooks.TypeOrder type = 6;
     */
    type: TypeOrder;
    /**
     * @generated from protobuf field: int64 createdAt = 7;
     */
    createdAt: bigint;
    /**
     * @generated from protobuf field: string price = 8;
     */
    price: string;
    /**
     * @generated from protobuf field: string paid = 9;
     */
    paid: string;
    /**
     * @generated from protobuf field: string averagePrice = 10;
     */
    averagePrice: string;
    /**
     * @generated from protobuf field: string quantity = 11;
     */
    quantity: string;
    /**
     * @generated from protobuf field: string filledQuantity = 12;
     */
    filledQuantity: string;
    /**
     * @generated from protobuf field: string originalQuantity = 13;
     */
    originalQuantity: string;
    /**
     * @generated from protobuf field: bool partiallyFilled = 14;
     */
    partiallyFilled: boolean;
}
/**
 * @generated from protobuf message orderbooks.OrderListArgs
 */
export interface OrderListArgs {
    /**
     * @generated from protobuf field: string symbol = 1;
     */
    symbol: string;
    /**
     * @generated from protobuf field: string from = 2;
     */
    from: string;
    /**
     * @generated from protobuf field: int32 limit = 3;
     */
    limit: number;
    /**
     * @generated from protobuf field: bool isOpen = 4;
     */
    isOpen: boolean;
}
/**
 * @generated from protobuf message orderbooks.SubscribeL2Args
 */
export interface SubscribeL2Args {
    /**
     * @generated from protobuf field: string symbol = 1;
     */
    symbol: string;
}
/**
 * @generated from protobuf message orderbooks.Prices
 */
export interface Prices {
    /**
     * @generated from protobuf field: int64 timestamp = 1;
     */
    timestamp: bigint;
    /**
     * @generated from protobuf field: repeated orderbooks.PriceLevel asks = 2;
     */
    asks: PriceLevel[];
    /**
     * @generated from protobuf field: repeated orderbooks.PriceLevel bids = 3;
     */
    bids: PriceLevel[];
}
/**
 * @generated from protobuf message orderbooks.PriceLevel
 */
export interface PriceLevel {
    /**
     * @generated from protobuf field: string price = 1;
     */
    price: string;
    /**
     * @generated from protobuf field: string quantity = 2;
     */
    quantity: string;
    /**
     * @generated from protobuf field: string type = 3;
     */
    type: string;
}
/**
 * Limit: side Side, quantity decimal.Decimal, price decimal.Decimal
 * Market: side Side, quantity decimal.Decimal
 *
 * @generated from protobuf message orderbooks.OrderArgs
 */
export interface OrderArgs {
    /**
     * @generated from protobuf field: string symbol = 1;
     */
    symbol: string;
    /**
     * @generated from protobuf field: orderbooks.TypeOrder type = 2;
     */
    type: TypeOrder;
    /**
     * @generated from protobuf field: orderbooks.SideOrder side = 3;
     */
    side: SideOrder;
    /**
     * @generated from protobuf field: string quantity = 4;
     */
    quantity: string;
    /**
     * @generated from protobuf field: string price = 5;
     */
    price: string;
}
/**
 * @generated from protobuf message orderbooks.CancelOrderArgs
 */
export interface CancelOrderArgs {
    /**
     * @generated from protobuf field: string orderId = 1;
     */
    orderId: string;
}
/**
 * @generated from protobuf enum orderbooks.TypeOrder
 */
export enum TypeOrder {
    /**
     * @generated from protobuf enum value: LIMIT = 0;
     */
    LIMIT = 0,
    /**
     * @generated from protobuf enum value: MARKET = 1;
     */
    MARKET = 1
}
/**
 * @generated from protobuf enum orderbooks.SideOrder
 */
export enum SideOrder {
    /**
     * @generated from protobuf enum value: BUY = 0;
     */
    BUY = 0,
    /**
     * @generated from protobuf enum value: SELL = 1;
     */
    SELL = 1
}
// @generated message type with reflection information, may provide speed optimized methods
class OrderListResult$Type extends MessageType<OrderListResult> {
    constructor() {
        super("orderbooks.OrderListResult", [
            { no: 1, name: "next", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 2, name: "orders", kind: "message", repeat: 1 /*RepeatType.PACKED*/, T: () => Order }
        ]);
    }
    create(value?: PartialMessage<OrderListResult>): OrderListResult {
        const message = { next: "", orders: [] };
        globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            reflectionMergePartial<OrderListResult>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: OrderListResult): OrderListResult {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* string next */ 1:
                    message.next = reader.string();
                    break;
                case /* repeated orderbooks.Order orders */ 2:
                    message.orders.push(Order.internalBinaryRead(reader, reader.uint32(), options));
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: OrderListResult, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* string next = 1; */
        if (message.next !== "")
            writer.tag(1, WireType.LengthDelimited).string(message.next);
        /* repeated orderbooks.Order orders = 2; */
        for (let i = 0; i < message.orders.length; i++)
            Order.internalBinaryWrite(message.orders[i], writer.tag(2, WireType.LengthDelimited).fork(), options).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message orderbooks.OrderListResult
 */
export const OrderListResult = new OrderListResult$Type();
// @generated message type with reflection information, may provide speed optimized methods
class Order$Type extends MessageType<Order> {
    constructor() {
        super("orderbooks.Order", [
            { no: 1, name: "id", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 2, name: "status", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 3, name: "userId", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 4, name: "symbol", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 5, name: "side", kind: "enum", T: () => ["orderbooks.SideOrder", SideOrder] },
            { no: 6, name: "type", kind: "enum", T: () => ["orderbooks.TypeOrder", TypeOrder] },
            { no: 7, name: "createdAt", kind: "scalar", T: 3 /*ScalarType.INT64*/, L: 0 /*LongType.BIGINT*/ },
            { no: 8, name: "price", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 9, name: "paid", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 10, name: "averagePrice", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 11, name: "quantity", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 12, name: "filledQuantity", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 13, name: "originalQuantity", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 14, name: "partiallyFilled", kind: "scalar", T: 8 /*ScalarType.BOOL*/ }
        ]);
    }
    create(value?: PartialMessage<Order>): Order {
        const message = { id: "", status: "", userId: "", symbol: "", side: 0, type: 0, createdAt: 0n, price: "", paid: "", averagePrice: "", quantity: "", filledQuantity: "", originalQuantity: "", partiallyFilled: false };
        globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            reflectionMergePartial<Order>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: Order): Order {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* string id */ 1:
                    message.id = reader.string();
                    break;
                case /* string status */ 2:
                    message.status = reader.string();
                    break;
                case /* string userId */ 3:
                    message.userId = reader.string();
                    break;
                case /* string symbol */ 4:
                    message.symbol = reader.string();
                    break;
                case /* orderbooks.SideOrder side */ 5:
                    message.side = reader.int32();
                    break;
                case /* orderbooks.TypeOrder type */ 6:
                    message.type = reader.int32();
                    break;
                case /* int64 createdAt */ 7:
                    message.createdAt = reader.int64().toBigInt();
                    break;
                case /* string price */ 8:
                    message.price = reader.string();
                    break;
                case /* string paid */ 9:
                    message.paid = reader.string();
                    break;
                case /* string averagePrice */ 10:
                    message.averagePrice = reader.string();
                    break;
                case /* string quantity */ 11:
                    message.quantity = reader.string();
                    break;
                case /* string filledQuantity */ 12:
                    message.filledQuantity = reader.string();
                    break;
                case /* string originalQuantity */ 13:
                    message.originalQuantity = reader.string();
                    break;
                case /* bool partiallyFilled */ 14:
                    message.partiallyFilled = reader.bool();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: Order, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* string id = 1; */
        if (message.id !== "")
            writer.tag(1, WireType.LengthDelimited).string(message.id);
        /* string status = 2; */
        if (message.status !== "")
            writer.tag(2, WireType.LengthDelimited).string(message.status);
        /* string userId = 3; */
        if (message.userId !== "")
            writer.tag(3, WireType.LengthDelimited).string(message.userId);
        /* string symbol = 4; */
        if (message.symbol !== "")
            writer.tag(4, WireType.LengthDelimited).string(message.symbol);
        /* orderbooks.SideOrder side = 5; */
        if (message.side !== 0)
            writer.tag(5, WireType.Varint).int32(message.side);
        /* orderbooks.TypeOrder type = 6; */
        if (message.type !== 0)
            writer.tag(6, WireType.Varint).int32(message.type);
        /* int64 createdAt = 7; */
        if (message.createdAt !== 0n)
            writer.tag(7, WireType.Varint).int64(message.createdAt);
        /* string price = 8; */
        if (message.price !== "")
            writer.tag(8, WireType.LengthDelimited).string(message.price);
        /* string paid = 9; */
        if (message.paid !== "")
            writer.tag(9, WireType.LengthDelimited).string(message.paid);
        /* string averagePrice = 10; */
        if (message.averagePrice !== "")
            writer.tag(10, WireType.LengthDelimited).string(message.averagePrice);
        /* string quantity = 11; */
        if (message.quantity !== "")
            writer.tag(11, WireType.LengthDelimited).string(message.quantity);
        /* string filledQuantity = 12; */
        if (message.filledQuantity !== "")
            writer.tag(12, WireType.LengthDelimited).string(message.filledQuantity);
        /* string originalQuantity = 13; */
        if (message.originalQuantity !== "")
            writer.tag(13, WireType.LengthDelimited).string(message.originalQuantity);
        /* bool partiallyFilled = 14; */
        if (message.partiallyFilled !== false)
            writer.tag(14, WireType.Varint).bool(message.partiallyFilled);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message orderbooks.Order
 */
export const Order = new Order$Type();
// @generated message type with reflection information, may provide speed optimized methods
class OrderListArgs$Type extends MessageType<OrderListArgs> {
    constructor() {
        super("orderbooks.OrderListArgs", [
            { no: 1, name: "symbol", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 2, name: "from", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 3, name: "limit", kind: "scalar", T: 5 /*ScalarType.INT32*/ },
            { no: 4, name: "isOpen", kind: "scalar", T: 8 /*ScalarType.BOOL*/ }
        ]);
    }
    create(value?: PartialMessage<OrderListArgs>): OrderListArgs {
        const message = { symbol: "", from: "", limit: 0, isOpen: false };
        globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            reflectionMergePartial<OrderListArgs>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: OrderListArgs): OrderListArgs {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* string symbol */ 1:
                    message.symbol = reader.string();
                    break;
                case /* string from */ 2:
                    message.from = reader.string();
                    break;
                case /* int32 limit */ 3:
                    message.limit = reader.int32();
                    break;
                case /* bool isOpen */ 4:
                    message.isOpen = reader.bool();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: OrderListArgs, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* string symbol = 1; */
        if (message.symbol !== "")
            writer.tag(1, WireType.LengthDelimited).string(message.symbol);
        /* string from = 2; */
        if (message.from !== "")
            writer.tag(2, WireType.LengthDelimited).string(message.from);
        /* int32 limit = 3; */
        if (message.limit !== 0)
            writer.tag(3, WireType.Varint).int32(message.limit);
        /* bool isOpen = 4; */
        if (message.isOpen !== false)
            writer.tag(4, WireType.Varint).bool(message.isOpen);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message orderbooks.OrderListArgs
 */
export const OrderListArgs = new OrderListArgs$Type();
// @generated message type with reflection information, may provide speed optimized methods
class SubscribeL2Args$Type extends MessageType<SubscribeL2Args> {
    constructor() {
        super("orderbooks.SubscribeL2Args", [
            { no: 1, name: "symbol", kind: "scalar", T: 9 /*ScalarType.STRING*/ }
        ]);
    }
    create(value?: PartialMessage<SubscribeL2Args>): SubscribeL2Args {
        const message = { symbol: "" };
        globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            reflectionMergePartial<SubscribeL2Args>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: SubscribeL2Args): SubscribeL2Args {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* string symbol */ 1:
                    message.symbol = reader.string();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: SubscribeL2Args, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* string symbol = 1; */
        if (message.symbol !== "")
            writer.tag(1, WireType.LengthDelimited).string(message.symbol);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message orderbooks.SubscribeL2Args
 */
export const SubscribeL2Args = new SubscribeL2Args$Type();
// @generated message type with reflection information, may provide speed optimized methods
class Prices$Type extends MessageType<Prices> {
    constructor() {
        super("orderbooks.Prices", [
            { no: 1, name: "timestamp", kind: "scalar", T: 3 /*ScalarType.INT64*/, L: 0 /*LongType.BIGINT*/ },
            { no: 2, name: "asks", kind: "message", repeat: 1 /*RepeatType.PACKED*/, T: () => PriceLevel },
            { no: 3, name: "bids", kind: "message", repeat: 1 /*RepeatType.PACKED*/, T: () => PriceLevel }
        ]);
    }
    create(value?: PartialMessage<Prices>): Prices {
        const message = { timestamp: 0n, asks: [], bids: [] };
        globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            reflectionMergePartial<Prices>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: Prices): Prices {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* int64 timestamp */ 1:
                    message.timestamp = reader.int64().toBigInt();
                    break;
                case /* repeated orderbooks.PriceLevel asks */ 2:
                    message.asks.push(PriceLevel.internalBinaryRead(reader, reader.uint32(), options));
                    break;
                case /* repeated orderbooks.PriceLevel bids */ 3:
                    message.bids.push(PriceLevel.internalBinaryRead(reader, reader.uint32(), options));
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: Prices, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* int64 timestamp = 1; */
        if (message.timestamp !== 0n)
            writer.tag(1, WireType.Varint).int64(message.timestamp);
        /* repeated orderbooks.PriceLevel asks = 2; */
        for (let i = 0; i < message.asks.length; i++)
            PriceLevel.internalBinaryWrite(message.asks[i], writer.tag(2, WireType.LengthDelimited).fork(), options).join();
        /* repeated orderbooks.PriceLevel bids = 3; */
        for (let i = 0; i < message.bids.length; i++)
            PriceLevel.internalBinaryWrite(message.bids[i], writer.tag(3, WireType.LengthDelimited).fork(), options).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message orderbooks.Prices
 */
export const Prices = new Prices$Type();
// @generated message type with reflection information, may provide speed optimized methods
class PriceLevel$Type extends MessageType<PriceLevel> {
    constructor() {
        super("orderbooks.PriceLevel", [
            { no: 1, name: "price", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 2, name: "quantity", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 3, name: "type", kind: "scalar", T: 9 /*ScalarType.STRING*/ }
        ]);
    }
    create(value?: PartialMessage<PriceLevel>): PriceLevel {
        const message = { price: "", quantity: "", type: "" };
        globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            reflectionMergePartial<PriceLevel>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: PriceLevel): PriceLevel {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* string price */ 1:
                    message.price = reader.string();
                    break;
                case /* string quantity */ 2:
                    message.quantity = reader.string();
                    break;
                case /* string type */ 3:
                    message.type = reader.string();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: PriceLevel, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* string price = 1; */
        if (message.price !== "")
            writer.tag(1, WireType.LengthDelimited).string(message.price);
        /* string quantity = 2; */
        if (message.quantity !== "")
            writer.tag(2, WireType.LengthDelimited).string(message.quantity);
        /* string type = 3; */
        if (message.type !== "")
            writer.tag(3, WireType.LengthDelimited).string(message.type);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message orderbooks.PriceLevel
 */
export const PriceLevel = new PriceLevel$Type();
// @generated message type with reflection information, may provide speed optimized methods
class OrderArgs$Type extends MessageType<OrderArgs> {
    constructor() {
        super("orderbooks.OrderArgs", [
            { no: 1, name: "symbol", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 2, name: "type", kind: "enum", T: () => ["orderbooks.TypeOrder", TypeOrder] },
            { no: 3, name: "side", kind: "enum", T: () => ["orderbooks.SideOrder", SideOrder] },
            { no: 4, name: "quantity", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 5, name: "price", kind: "scalar", T: 9 /*ScalarType.STRING*/ }
        ]);
    }
    create(value?: PartialMessage<OrderArgs>): OrderArgs {
        const message = { symbol: "", type: 0, side: 0, quantity: "", price: "" };
        globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            reflectionMergePartial<OrderArgs>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: OrderArgs): OrderArgs {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* string symbol */ 1:
                    message.symbol = reader.string();
                    break;
                case /* orderbooks.TypeOrder type */ 2:
                    message.type = reader.int32();
                    break;
                case /* orderbooks.SideOrder side */ 3:
                    message.side = reader.int32();
                    break;
                case /* string quantity */ 4:
                    message.quantity = reader.string();
                    break;
                case /* string price */ 5:
                    message.price = reader.string();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: OrderArgs, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* string symbol = 1; */
        if (message.symbol !== "")
            writer.tag(1, WireType.LengthDelimited).string(message.symbol);
        /* orderbooks.TypeOrder type = 2; */
        if (message.type !== 0)
            writer.tag(2, WireType.Varint).int32(message.type);
        /* orderbooks.SideOrder side = 3; */
        if (message.side !== 0)
            writer.tag(3, WireType.Varint).int32(message.side);
        /* string quantity = 4; */
        if (message.quantity !== "")
            writer.tag(4, WireType.LengthDelimited).string(message.quantity);
        /* string price = 5; */
        if (message.price !== "")
            writer.tag(5, WireType.LengthDelimited).string(message.price);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message orderbooks.OrderArgs
 */
export const OrderArgs = new OrderArgs$Type();
// @generated message type with reflection information, may provide speed optimized methods
class CancelOrderArgs$Type extends MessageType<CancelOrderArgs> {
    constructor() {
        super("orderbooks.CancelOrderArgs", [
            { no: 1, name: "orderId", kind: "scalar", T: 9 /*ScalarType.STRING*/ }
        ]);
    }
    create(value?: PartialMessage<CancelOrderArgs>): CancelOrderArgs {
        const message = { orderId: "" };
        globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            reflectionMergePartial<CancelOrderArgs>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: CancelOrderArgs): CancelOrderArgs {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* string orderId */ 1:
                    message.orderId = reader.string();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: CancelOrderArgs, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* string orderId = 1; */
        if (message.orderId !== "")
            writer.tag(1, WireType.LengthDelimited).string(message.orderId);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message orderbooks.CancelOrderArgs
 */
export const CancelOrderArgs = new CancelOrderArgs$Type();
/**
 * @generated ServiceType for protobuf service orderbooks.Orderbooks
 */
export const Orderbooks = new ServiceType("orderbooks.Orderbooks", [
    { name: "SubscribeL2", serverStreaming: true, options: {}, I: SubscribeL2Args, O: Prices },
    { name: "ProcessOrder", options: {}, I: OrderArgs, O: Order },
    { name: "CancelOrder", options: {}, I: CancelOrderArgs, O: Order },
    { name: "OrderList", options: {}, I: OrderListArgs, O: OrderListResult }
]);
